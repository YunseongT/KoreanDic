<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>한국어 단어 확장 사전</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .search-section {
            padding: 30px;
            background: white;
        }

        .search-container {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            max-width: 600px;
            margin: 0 auto 20px auto;
        }

        .search-input {
            flex: 1;
            padding: 15px 20px;
            border: 2px solid #e0e0e0;
            border-radius: 50px;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .search-input:focus {
            outline: none;
            border-color: #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.2);
        }

        .search-btn {
            padding: 15px 30px;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 50px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .search-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.3);
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4CAF50;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .results {
            padding: 0 30px 30px;
        }

        .category-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .category-card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
            overflow: hidden;
            transition: transform 0.3s ease;
        }

        .category-card:hover {
            transform: translateY(-5px);
        }

        .category-header {
            padding: 20px;
            font-weight: 700;
            font-size: 1.2rem;
            color: white;
            text-align: center;
        }

        .definition .category-header {
            background: linear-gradient(135deg, #FF6B6B, #FF8E8E);
        }

        .homonym .category-header {
            background: linear-gradient(135deg, #4ECDC4, #6DD5D1);
        }

        .synonym .category-header {
            background: linear-gradient(135deg, #45B7D1, #69C9E0);
        }

        .antonym .category-header {
            background: linear-gradient(135deg, #96CEB4, #A8D8C4);
        }

        .rhyme .category-header {
            background: linear-gradient(135deg, #FECA57, #FED766);
        }

        .category-content {
            padding: 20px;
        }

        .definition-text {
            font-size: 1.1rem;
            line-height: 1.6;
            color: #333;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #FF6B6B;
        }

        .word-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .word-tag {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .homonym-item {
            background: #f8f9fa;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            border-left: 4px solid #4ECDC4;
        }

        .homonym-item .word {
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }

        .homonym-item .definition {
            color: #666;
            line-height: 1.5;
        }

        .empty-state {
            text-align: center;
            color: #999;
            font-style: italic;
            padding: 20px;
        }

        .error {
            background: #ffebee;
            color: #c62828;
            padding: 20px;
            border-radius: 8px;
            margin: 20px;
            text-align: center;
            border: 1px solid #ffcdd2;
        }

        .api-status {
            background: #e3f2fd;
            color: #1976d2;
            padding: 15px;
            border-radius: 8px;
            margin: 20px;
            text-align: center;
            border: 1px solid #bbdefb;
            font-size: 0.9rem;
        }

        .proxy-status {
            background: #f3e5f5;
            color: #7b1fa2;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-size: 0.85rem;
        }

        @media (max-width: 768px) {
            .category-grid {
                grid-template-columns: 1fr;
            }
            
            .search-container {
                flex-direction: column;
            }
            
            .header h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>📚 한국어 단어 확장 사전</h1>
            <p>단어를 입력하여 정의, 동음이의어, 유의어, 반의어, 각운을 찾아보세요</p>
        </div>

        <div class="search-section">
            <div class="search-container">
                <input type="text" class="search-input" placeholder="검색할 단어를 입력하세요 (예: 사과, 말, 배, 빛, 물)" id="searchInput">
                <button class="search-btn" onclick="searchWord()">🔍 찾기</button>
            </div>
            <div class="api-status">
                🌐 실시간 국립국어원 우리말샘 API 연결
            </div>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p id="loadingText">단어 정보를 검색하는 중입니다...</p>
            <div class="proxy-status" id="proxyStatus"></div>
        </div>

        <div class="results" id="results"></div>
    </div>

    <script>
        const API_KEY = '1735A5341E757DC9336240C30F8F24A7';
        
        // 여러 CORS 프록시 서버 목록 (안정성 향상)
        const PROXY_SERVERS = [
            'https://api.allorigins.win/get?url=',
            'https://corsproxy.io/?',
            'https://api.codetabs.com/v1/proxy?quest=',
            'https://cors-anywhere.herokuapp.com/',
            'https://thingproxy.freeboard.io/fetch/'
        ];
        
        let currentProxyIndex = 0;

        // Enter 키로 검색 가능하게 하기
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchWord();
            }
        });

        async function searchWord() {
            const searchTerm = document.getElementById('searchInput').value.trim();
            if (!searchTerm) {
                alert('검색할 단어를 입력해주세요.');
                return;
            }

            showLoading();
            await trySearchWithMultipleProxies(searchTerm);
        }

        async function trySearchWithMultipleProxies(searchTerm) {
            for (let i = 0; i < PROXY_SERVERS.length; i++) {
                currentProxyIndex = i;
                updateProxyStatus(`프록시 서버 ${i + 1}/${PROXY_SERVERS.length} 시도 중...`);
                
                try {
                    const result = await searchWithProxy(searchTerm, i);
                    if (result) {
                        hideLoading();
                        displayResults(searchTerm, result);
                        return;
                    }
                } catch (error) {
                    console.log(`프록시 서버 ${i + 1} 실패:`, error.message);
                    
                    if (i === PROXY_SERVERS.length - 1) {
                        // 모든 프록시 실패시 직접 호출 시도
                        try {
                            updateProxyStatus('직접 API 호출 시도 중...');
                            const result = await searchDirectly(searchTerm);
                            if (result) {
                                hideLoading();
                                displayResults(searchTerm, result);
                                return;
                            }
                        } catch (directError) {
                            console.log('직접 호출도 실패:', directError.message);
                        }
                        
                        hideLoading();
                        showError(`모든 연결 방법을 시도했지만 API에 접근할 수 없습니다.<br>
                                  네트워크 연결을 확인하고 잠시 후 다시 시도해주세요.<br>
                                  <small>오류: CORS 정책 또는 서버 접근 제한</small>`);
                    }
                }
                
                // 다음 프록시 시도 전 잠시 대기
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
        }

        async function searchWithProxy(searchTerm, proxyIndex) {
            const proxy = PROXY_SERVERS[proxyIndex];
            const apiUrl = `https://opendict.korean.go.kr/api/search.do?key=${API_KEY}&q=${encodeURIComponent(searchTerm)}&req_type=json&part=word&pos=1&start=1&num=30`;
            
            let requestUrl;
            if (proxy.includes('allorigins.win')) {
                requestUrl = `${proxy}${encodeURIComponent(apiUrl)}`;
            } else {
                requestUrl = proxy + apiUrl;
            }

            const response = await fetch(requestUrl, {
                method: 'GET',
                headers: {
                    'Accept': 'application/json',
                },
                timeout: 10000
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }

            const data = await response.json();
            
            // allorigins.win의 경우 contents 속성에 실제 데이터가 있음
            let apiData;
            if (data.contents) {
                try {
                    apiData = JSON.parse(data.contents);
                } catch (e) {
                    apiData = data.contents;
                }
            } else {
                apiData = data;
            }

            if (apiData && (apiData.channel || apiData.item)) {
                return apiData;
            }
            
            throw new Error('응답 데이터가 올바르지 않습니다');
        }

        async function searchDirectly(searchTerm) {
            // 직접 API 호출 (CORS 에러가 발생할 수 있지만 시도)
            const apiUrl = `https://opendict.korean.go.kr/api/search.do?key=${API_KEY}&q=${encodeURIComponent(searchTerm)}&req_type=json&part=word&pos=1&start=1&num=30`;
            
            const response = await fetch(apiUrl, {
                method: 'GET',
                mode: 'cors'
            });
            
            return await response.json();
        }

        function showLoading() {
            document.getElementById('loading').style.display = 'block';
            document.getElementById('results').innerHTML = '';
        }

        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
        }

        function updateProxyStatus(message) {
            document.getElementById('proxyStatus').textContent = message;
        }

        function showError(message) {
            document.getElementById('results').innerHTML = `<div class="error">${message}</div>`;
        }

        function displayResults(searchTerm, apiData) {
            let items = [];
            
            // 다양한 API 응답 형식 처리
            if (apiData.channel && apiData.channel.item) {
                items = Array.isArray(apiData.channel.item) ? apiData.channel.item : [apiData.channel.item];
            } else if (apiData.item) {
                items = Array.isArray(apiData.item) ? apiData.item : [apiData.item];
            } else if (Array.isArray(apiData)) {
                items = apiData;
            }

            if (items.length === 0) {
                showError('검색 결과가 없습니다. 다른 단어로 시도해보세요.');
                return;
            }

            // 데이터 분류 및 처리
            const mainDefinition = items[0];
            const homonyms = items.length > 1 ? items.slice(1) : [];
            
            // 관련어 정보 추출
            const synonyms = new Set();
            const antonyms = new Set();
            
            items.forEach(item => {
                // 관련어 정보에서 유의어/반의어 추출
                if (item.relation_info) {
                    extractRelatedWords(item.relation_info, synonyms, antonyms);
                }
                if (item.rel_info) {
                    extractRelatedWords(item.rel_info, synonyms, antonyms);
                }
                // 뜻풀이에서 관련어 찾기
                if (item.definition) {
                    extractFromDefinition(item.definition, synonyms, antonyms);
                }
            });

            // 각운 찾기
            const allWords = [...synonyms, ...antonyms];
            const rhymes = findRhymingWords(searchTerm, allWords);

            const resultsHtml = `
                <div class="category-grid">
                    <!-- 1. 검색 단어 정의 -->
                    <div class="category-card definition">
                        <div class="category-header">
                            📖 검색 단어 정의
                        </div>
                        <div class="category-content">
                            <div class="definition-text">
                                <strong>${searchTerm}</strong><br>
                                ${cleanDefinition(mainDefinition.definition)}
                                ${mainDefinition.pos ? `<br><small style="color: #666;">품사: ${mainDefinition.pos}</small>` : ''}
                            </div>
                        </div>
                    </div>

                    <!-- 2. 동음이의어 -->
                    <div class="category-card homonym">
                        <div class="category-header">
                            🔄 동음이의어
                        </div>
                        <div class="category-content">
                            ${homonyms.length > 0 ? 
                                homonyms.map((item, index) => `
                                    <div class="homonym-item">
                                        <div class="word">${item.word || searchTerm} (${index + 2})</div>
                                        <div class="definition">${cleanDefinition(item.definition)}</div>
                                        ${item.pos ? `<small style="color: #888;">품사: ${item.pos}</small>` : ''}
                                    </div>
                                `).join('') : 
                                '<div class="empty-state">동음이의어가 없습니다.</div>'
                            }
                        </div>
                    </div>

                    <!-- 3. 유의어 -->
                    <div class="category-card synonym">
                        <div class="category-header">
                            👥 유의어 (${synonyms.size}개)
                        </div>
                        <div class="category-content">
                            ${synonyms.size > 0 ? 
                                `<div class="word-list">
                                    ${Array.from(synonyms).map(word => `<span class="word-tag">${word}</span>`).join('')}
                                </div>` : 
                                '<div class="empty-state">유의어 정보가 없습니다.</div>'
                            }
                        </div>
                    </div>

                    <!-- 4. 반의어 -->
                    <div class="category-card antonym">
                        <div class="category-header">
                            ↔️ 반의어 (${antonyms.size}개)
                        </div>
                        <div class="category-content">
                            ${antonyms.size > 0 ? 
                                `<div class="word-list">
                                    ${Array.from(antonyms).map(word => `<span class="word-tag">${word}</span>`).join('')}
                                </div>` : 
                                '<div class="empty-state">반의어 정보가 없습니다.</div>'
                            }
                        </div>
                    </div>

                    <!-- 5. 각운이 맞는 단어 -->
                    <div class="category-card rhyme">
                        <div class="category-header">
                            🎵 각운이 맞는 단어 (${rhymes.length}개)
                        </div>
                        <div class="category-content">
                            ${rhymes.length > 0 ? 
                                `<div class="word-list">
                                    ${rhymes.map(word => `<span class="word-tag">${word}</span>`).join('')}
                                </div>` : 
                                '<div class="empty-state">각운이 맞는 단어가 없습니다.</div>'
                            }
                        </div>
                    </div>
                </div>
            `;

            document.getElementById('results').innerHTML = resultsHtml;
        }

        function extractRelatedWords(relationInfo, synonyms, antonyms) {
            if (!relationInfo) return;
            
            const text = relationInfo.toString().toLowerCase();
            
            // 유의어 패턴 매칭
            const synonymPatterns = [/비슷한말[:\s]*([^,]+)/g, /유의어[:\s]*([^,]+)/g, /같은말[:\s]*([^,]+)/g];
            synonymPatterns.forEach(pattern => {
                let match;
                while ((match = pattern.exec(text)) !== null) {
                    const words = match[1].split(/[,\s]+/).filter(w => w.length > 0 && w !== '없음');
                    words.forEach(word => synonyms.add(word.trim()));
                }
            });

            // 반의어 패턴 매칭
            const antonymPatterns = [/반의어[:\s]*([^,]+)/g, /반대말[:\s]*([^,]+)/g, /대조어[:\s]*([^,]+)/g];
            antonymPatterns.forEach(pattern => {
                let match;
                while ((match = pattern.exec(text)) !== null) {
                    const words = match[1].split(/[,\s]+/).filter(w => w.length > 0 && w !== '없음');
                    words.forEach(word => antonyms.add(word.trim()));
                }
            });
        }

        function extractFromDefinition(definition, synonyms, antonyms) {
            if (!definition) return;
            
            // 뜻풀이에서 "~와 같은", "~의 다른 말" 등의 패턴으로 관련어 찾기
            const synonymPatterns = [
                /['"]([^'"]+)['"]와\s*같은/g,
                /['"]([^'"]+)['"]의\s*다른\s*말/g,
                /['"]([^'"]+)['"]라고도/g
            ];
            
            synonymPatterns.forEach(pattern => {
                let match;
                while ((match = pattern.exec(definition)) !== null) {
                    synonyms.add(match[1].trim());
                }
            });
        }

        function findRhymingWords(searchTerm, wordList) {
            if (searchTerm.length === 0) return [];
            
            const lastChar = searchTerm.charAt(searchTerm.length - 1);
            const secondLastChar = searchTerm.length > 1 ? searchTerm.charAt(searchTerm.length - 2) : '';
            
            return wordList.filter(word => {
                if (word === searchTerm || word.length === 0) return false;
                
                // 마지막 글자가 같거나, 마지막 2글자가 같은 경우
                const wordLastChar = word.charAt(word.length - 1);
                const wordSecondLastChar = word.length > 1 ? word.charAt(word.length - 2) : '';
                
                return wordLastChar === lastChar || 
                       (secondLastChar && wordSecondLastChar === secondLastChar && wordLastChar === lastChar);
            });
        }

        function cleanDefinition(definition) {
            if (!definition) return '정의가 없습니다.';
            
            return definition
                .replace(/<[^>]*>/g, '')
                .replace(/&lt;/g, '<')
                .replace(/&gt;/g, '>')
                .replace(/&amp;/g, '&')
                .replace(/&quot;/g, '"')
                .replace(/&#x27;/g, "'")
                .replace(/\s+/g, ' ')
                .trim();
        }

        // 페이지 로드시 안내
        window.addEventListener('load', function() {
            console.log('한국어 단어 확장 사전이 로드되었습니다.');
            console.log('다중 프록시 서버를 통해 안정적인 API 연결을 제공합니다.');
        });
    </script>
</body>
</html>
